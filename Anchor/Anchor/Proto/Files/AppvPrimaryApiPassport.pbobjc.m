// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: appv-primary-api-passport.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "AppvPrimaryApiPassport.pbobjc.h"
#import "AppvBasic.pbobjc.h"
#import "AppvPrimaryTag.pbobjc.h"
#import "AppvUser.pbobjc.h"
#import "AppvVip.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(appvapiAppConfiguration);
GPBObjCClassDeclaration(appvapiConfig);
GPBObjCClassDeclaration(appvapiContentTag);
GPBObjCClassDeclaration(appvapiExchangeAnchorInfo);
GPBObjCClassDeclaration(appvapiExchangeUnCloseLiveInfo);
GPBObjCClassDeclaration(appvapiIdEncode);
GPBObjCClassDeclaration(appvapiNewMsgCount);
GPBObjCClassDeclaration(appvapiUserInfoBasic);
GPBObjCClassDeclaration(appvapiVipProduct);
GPBObjCClassDeclaration(appvapiVipProductAllInfo);
GPBObjCClassDeclaration(appvapiVipRightInterests);

#pragma mark - appvapiAppvPrimaryApiPassportRoot

@implementation appvapiAppvPrimaryApiPassportRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - appvapiAppvPrimaryApiPassportRoot_FileDescriptor

static GPBFileDescriptor *appvapiAppvPrimaryApiPassportRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"appvapi"
                                                 objcPrefix:@"appvapi"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum appvapiExchangeIsNotAnchorReason

GPBEnumDescriptor *appvapiExchangeIsNotAnchorReason_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ExchangeIsNotAnchorReasonApplyUnPass\000Exc"
        "hangeIsNotAnchorReasonApplyWaiting\000Excha"
        "ngeIsNotAnchorReasonApplyNot\000";
    static const int32_t values[] = {
        appvapiExchangeIsNotAnchorReason_ExchangeIsNotAnchorReasonApplyUnPass,
        appvapiExchangeIsNotAnchorReason_ExchangeIsNotAnchorReasonApplyWaiting,
        appvapiExchangeIsNotAnchorReason_ExchangeIsNotAnchorReasonApplyNot,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(appvapiExchangeIsNotAnchorReason)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:appvapiExchangeIsNotAnchorReason_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      
    }
  }
  return descriptor;
}

BOOL appvapiExchangeIsNotAnchorReason_IsValidValue(int32_t value__) {
  switch (value__) {
    case appvapiExchangeIsNotAnchorReason_ExchangeIsNotAnchorReasonApplyUnPass:
    case appvapiExchangeIsNotAnchorReason_ExchangeIsNotAnchorReasonApplyWaiting:
    case appvapiExchangeIsNotAnchorReason_ExchangeIsNotAnchorReasonApplyNot:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - appvapiEnterRequest

@implementation appvapiEnterRequest

@dynamic ucToken;

typedef struct appvapiEnterRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *ucToken;
} appvapiEnterRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ucToken",
        .dataTypeSpecific.clazz = Nil,
        .number = appvapiEnterRequest_FieldNumber_UcToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiEnterRequest__storage_, ucToken),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiEnterRequest class]
                                     rootClass:[appvapiAppvPrimaryApiPassportRoot class]
                                          file:appvapiAppvPrimaryApiPassportRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiEnterRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiEnterResponse

@implementation appvapiEnterResponse

@dynamic token;
@dynamic isNew;
@dynamic hasUserInfo, userInfo;
@dynamic hasConfig, config;

typedef struct appvapiEnterResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  appvapiUserInfoBasic *userInfo;
  appvapiConfig *config;
} appvapiEnterResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.clazz = Nil,
        .number = appvapiEnterResponse_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiEnterResponse__storage_, token),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isNew",
        .dataTypeSpecific.clazz = Nil,
        .number = appvapiEnterResponse_FieldNumber_IsNew,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "userInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiUserInfoBasic),
        .number = appvapiEnterResponse_FieldNumber_UserInfo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(appvapiEnterResponse__storage_, userInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "config",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiConfig),
        .number = appvapiEnterResponse_FieldNumber_Config,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(appvapiEnterResponse__storage_, config),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiEnterResponse class]
                                     rootClass:[appvapiAppvPrimaryApiPassportRoot class]
                                          file:appvapiAppvPrimaryApiPassportRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiEnterResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiConfigRequest

@implementation appvapiConfigRequest

@dynamic bootDataVersion;

typedef struct appvapiConfigRequest__storage_ {
  uint32_t _has_storage_[1];
  uint64_t bootDataVersion;
} appvapiConfigRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bootDataVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = appvapiConfigRequest_FieldNumber_BootDataVersion,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiConfigRequest__storage_, bootDataVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiConfigRequest class]
                                     rootClass:[appvapiAppvPrimaryApiPassportRoot class]
                                          file:appvapiAppvPrimaryApiPassportRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiConfigRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiConfigResponse

@implementation appvapiConfigResponse

@dynamic hasConfig, config;

typedef struct appvapiConfigResponse__storage_ {
  uint32_t _has_storage_[1];
  appvapiConfig *config;
} appvapiConfigResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "config",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiConfig),
        .number = appvapiConfigResponse_FieldNumber_Config,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiConfigResponse__storage_, config),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiConfigResponse class]
                                     rootClass:[appvapiAppvPrimaryApiPassportRoot class]
                                          file:appvapiAppvPrimaryApiPassportRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiConfigResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiConfig

@implementation appvapiConfig

@dynamic systemTagArray, systemTagArray_Count;
@dynamic appConfigurationsArray, appConfigurationsArray_Count;
@dynamic hasVipProductAllInfo, vipProductAllInfo;
@dynamic postTagArray, postTagArray_Count;

typedef struct appvapiConfig__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *systemTagArray;
  NSMutableArray *appConfigurationsArray;
  appvapiVipProductAllInfo *vipProductAllInfo;
  NSMutableArray *postTagArray;
} appvapiConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "systemTagArray",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiContentTag),
        .number = appvapiConfig_FieldNumber_SystemTagArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(appvapiConfig__storage_, systemTagArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "appConfigurationsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiAppConfiguration),
        .number = appvapiConfig_FieldNumber_AppConfigurationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(appvapiConfig__storage_, appConfigurationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "vipProductAllInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiVipProductAllInfo),
        .number = appvapiConfig_FieldNumber_VipProductAllInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiConfig__storage_, vipProductAllInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "postTagArray",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiContentTag),
        .number = appvapiConfig_FieldNumber_PostTagArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(appvapiConfig__storage_, postTagArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiConfig class]
                                     rootClass:[appvapiAppvPrimaryApiPassportRoot class]
                                          file:appvapiAppvPrimaryApiPassportRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiConfig__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiVipProductAllInfo

@implementation appvapiVipProductAllInfo

@dynamic vipProductsArray, vipProductsArray_Count;
@dynamic vipRightInterestssArray, vipRightInterestssArray_Count;

typedef struct appvapiVipProductAllInfo__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *vipProductsArray;
  NSMutableArray *vipRightInterestssArray;
} appvapiVipProductAllInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "vipProductsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiVipProduct),
        .number = appvapiVipProductAllInfo_FieldNumber_VipProductsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(appvapiVipProductAllInfo__storage_, vipProductsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "vipRightInterestssArray",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiVipRightInterests),
        .number = appvapiVipProductAllInfo_FieldNumber_VipRightInterestssArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(appvapiVipProductAllInfo__storage_, vipRightInterestssArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiVipProductAllInfo class]
                                     rootClass:[appvapiAppvPrimaryApiPassportRoot class]
                                          file:appvapiAppvPrimaryApiPassportRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiVipProductAllInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiAppConfiguration

@implementation appvapiAppConfiguration

@dynamic configurationItemKey;
@dynamic configurationItemValue;

typedef struct appvapiAppConfiguration__storage_ {
  uint32_t _has_storage_[1];
  NSString *configurationItemKey;
  NSString *configurationItemValue;
} appvapiAppConfiguration__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "configurationItemKey",
        .dataTypeSpecific.clazz = Nil,
        .number = appvapiAppConfiguration_FieldNumber_ConfigurationItemKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiAppConfiguration__storage_, configurationItemKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "configurationItemValue",
        .dataTypeSpecific.clazz = Nil,
        .number = appvapiAppConfiguration_FieldNumber_ConfigurationItemValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(appvapiAppConfiguration__storage_, configurationItemValue),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiAppConfiguration class]
                                     rootClass:[appvapiAppvPrimaryApiPassportRoot class]
                                          file:appvapiAppvPrimaryApiPassportRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiAppConfiguration__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiChatAuthRequest

@implementation appvapiChatAuthRequest


typedef struct appvapiChatAuthRequest__storage_ {
  uint32_t _has_storage_[1];
} appvapiChatAuthRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiChatAuthRequest class]
                                     rootClass:[appvapiAppvPrimaryApiPassportRoot class]
                                          file:appvapiAppvPrimaryApiPassportRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(appvapiChatAuthRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiChatAuthResponse

@implementation appvapiChatAuthResponse

@dynamic chatToken;
@dynamic gatewayJwtToken;
@dynamic hasNewMsgCount, newMsgCount;
@dynamic hasExchangeAnchorInfo, exchangeAnchorInfo;
@dynamic hasExchangeUnCloseLiveInfo, exchangeUnCloseLiveInfo;

typedef struct appvapiChatAuthResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *chatToken;
  NSString *gatewayJwtToken;
  appvapiNewMsgCount *newMsgCount;
  appvapiExchangeAnchorInfo *exchangeAnchorInfo;
  appvapiExchangeUnCloseLiveInfo *exchangeUnCloseLiveInfo;
} appvapiChatAuthResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatToken",
        .dataTypeSpecific.clazz = Nil,
        .number = appvapiChatAuthResponse_FieldNumber_ChatToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiChatAuthResponse__storage_, chatToken),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gatewayJwtToken",
        .dataTypeSpecific.clazz = Nil,
        .number = appvapiChatAuthResponse_FieldNumber_GatewayJwtToken,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(appvapiChatAuthResponse__storage_, gatewayJwtToken),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newMsgCount",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiNewMsgCount),
        .number = appvapiChatAuthResponse_FieldNumber_NewMsgCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(appvapiChatAuthResponse__storage_, newMsgCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "exchangeAnchorInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiExchangeAnchorInfo),
        .number = appvapiChatAuthResponse_FieldNumber_ExchangeAnchorInfo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(appvapiChatAuthResponse__storage_, exchangeAnchorInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "exchangeUnCloseLiveInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiExchangeUnCloseLiveInfo),
        .number = appvapiChatAuthResponse_FieldNumber_ExchangeUnCloseLiveInfo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(appvapiChatAuthResponse__storage_, exchangeUnCloseLiveInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiChatAuthResponse class]
                                     rootClass:[appvapiAppvPrimaryApiPassportRoot class]
                                          file:appvapiAppvPrimaryApiPassportRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiChatAuthResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiGetNoticeResponse

@implementation appvapiGetNoticeResponse

@dynamic hasNewMsgCount, newMsgCount;

typedef struct appvapiGetNoticeResponse__storage_ {
  uint32_t _has_storage_[1];
  appvapiNewMsgCount *newMsgCount;
} appvapiGetNoticeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "newMsgCount",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiNewMsgCount),
        .number = appvapiGetNoticeResponse_FieldNumber_NewMsgCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiGetNoticeResponse__storage_, newMsgCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiGetNoticeResponse class]
                                     rootClass:[appvapiAppvPrimaryApiPassportRoot class]
                                          file:appvapiAppvPrimaryApiPassportRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiGetNoticeResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiNewMsgCount

@implementation appvapiNewMsgCount

@dynamic chatNewCount;
@dynamic subNewCount;
@dynamic workOrderNewCount;

typedef struct appvapiNewMsgCount__storage_ {
  uint32_t _has_storage_[1];
  uint32_t chatNewCount;
  uint32_t subNewCount;
  uint32_t workOrderNewCount;
} appvapiNewMsgCount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatNewCount",
        .dataTypeSpecific.clazz = Nil,
        .number = appvapiNewMsgCount_FieldNumber_ChatNewCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiNewMsgCount__storage_, chatNewCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "subNewCount",
        .dataTypeSpecific.clazz = Nil,
        .number = appvapiNewMsgCount_FieldNumber_SubNewCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(appvapiNewMsgCount__storage_, subNewCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "workOrderNewCount",
        .dataTypeSpecific.clazz = Nil,
        .number = appvapiNewMsgCount_FieldNumber_WorkOrderNewCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(appvapiNewMsgCount__storage_, workOrderNewCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiNewMsgCount class]
                                     rootClass:[appvapiAppvPrimaryApiPassportRoot class]
                                          file:appvapiAppvPrimaryApiPassportRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiNewMsgCount__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiExchangeAnchorInfo

@implementation appvapiExchangeAnchorInfo

@dynamic isAnchor;
@dynamic exchangeIsNotAnchorReason;

typedef struct appvapiExchangeAnchorInfo__storage_ {
  uint32_t _has_storage_[1];
  appvapiExchangeIsNotAnchorReason exchangeIsNotAnchorReason;
} appvapiExchangeAnchorInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isAnchor",
        .dataTypeSpecific.clazz = Nil,
        .number = appvapiExchangeAnchorInfo_FieldNumber_IsAnchor,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "exchangeIsNotAnchorReason",
        .dataTypeSpecific.enumDescFunc = appvapiExchangeIsNotAnchorReason_EnumDescriptor,
        .number = appvapiExchangeAnchorInfo_FieldNumber_ExchangeIsNotAnchorReason,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(appvapiExchangeAnchorInfo__storage_, exchangeIsNotAnchorReason),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiExchangeAnchorInfo class]
                                     rootClass:[appvapiAppvPrimaryApiPassportRoot class]
                                          file:appvapiAppvPrimaryApiPassportRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiExchangeAnchorInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t appvapiExchangeAnchorInfo_ExchangeIsNotAnchorReason_RawValue(appvapiExchangeAnchorInfo *message) {
  GPBDescriptor *descriptor = [appvapiExchangeAnchorInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:appvapiExchangeAnchorInfo_FieldNumber_ExchangeIsNotAnchorReason];
  return GPBGetMessageRawEnumField(message, field);
}

void SetappvapiExchangeAnchorInfo_ExchangeIsNotAnchorReason_RawValue(appvapiExchangeAnchorInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [appvapiExchangeAnchorInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:appvapiExchangeAnchorInfo_FieldNumber_ExchangeIsNotAnchorReason];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - appvapiExchangeUnCloseLiveInfo

@implementation appvapiExchangeUnCloseLiveInfo

@dynamic hasLiveId, liveId;

typedef struct appvapiExchangeUnCloseLiveInfo__storage_ {
  uint32_t _has_storage_[1];
  appvapiIdEncode *liveId;
} appvapiExchangeUnCloseLiveInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "liveId",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiIdEncode),
        .number = appvapiExchangeUnCloseLiveInfo_FieldNumber_LiveId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiExchangeUnCloseLiveInfo__storage_, liveId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiExchangeUnCloseLiveInfo class]
                                     rootClass:[appvapiAppvPrimaryApiPassportRoot class]
                                          file:appvapiAppvPrimaryApiPassportRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiExchangeUnCloseLiveInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
