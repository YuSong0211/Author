// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: exchange-primary-push-notice.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "ExchangePrimaryPushNotice.pbobjc.h"
#import "ExchangeBasic.pbobjc.h"
#import "ExchangePrimaryApiLive.pbobjc.h"
#import "ExchangePrimaryMsg.pbobjc.h"
#import "UtilBasicIdentity.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(serviceexchangeAnchorApplyNotice);
GPBObjCClassDeclaration(serviceexchangeAnchorApplyNotice_PushNotice);
GPBObjCClassDeclaration(serviceexchangeAnchorBackLiveNotice);
GPBObjCClassDeclaration(serviceexchangeAnchorBackLiveNotice_PushNotice);
GPBObjCClassDeclaration(serviceexchangeAnchorLeaveLiveNotice);
GPBObjCClassDeclaration(serviceexchangeAnchorLeaveLiveNotice_PushNotice);
GPBObjCClassDeclaration(serviceexchangeChatLiveNotice);
GPBObjCClassDeclaration(serviceexchangeChatLiveNotice_PushNotice);
GPBObjCClassDeclaration(serviceexchangeChatUser);
GPBObjCClassDeclaration(serviceexchangeCloseLiveNotice);
GPBObjCClassDeclaration(serviceexchangeCloseLiveNotice_PushNotice);
GPBObjCClassDeclaration(serviceexchangeEnterLiveNotice);
GPBObjCClassDeclaration(serviceexchangeEnterLiveNotice_PushNotice);
GPBObjCClassDeclaration(serviceexchangeExitLiveNotice);
GPBObjCClassDeclaration(serviceexchangeExitLiveNotice_PushNotice);
GPBObjCClassDeclaration(serviceexchangeLiveGiftNotice);
GPBObjCClassDeclaration(serviceexchangeLiveGiftNotice_PushNotice);
GPBObjCClassDeclaration(serviceexchangeLiveUserListResponse);
GPBObjCClassDeclaration(serviceexchangeMessageCount);
GPBObjCClassDeclaration(serviceexchangeMessageUserNotice);
GPBObjCClassDeclaration(serviceexchangeMessageUserNotice_ChatNotice);
GPBObjCClassDeclaration(serviceexchangeMessageUserNotice_PushNotice);
GPBObjCClassDeclaration(serviceexchangeMessageUserNotice_TemplateNotice);
GPBObjCClassDeclaration(serviceexchangeUserStatusNotice);
GPBObjCClassDeclaration(serviceexchangeUserStatusNotice_PushNotice);
GPBObjCClassDeclaration(serviceexchangeVersionId);
GPBObjCClassDeclaration(utilidentitysdkIdEncode);

#pragma mark - serviceexchangeExchangePrimaryPushNoticeRoot

@implementation serviceexchangeExchangePrimaryPushNoticeRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor

static GPBFileDescriptor *serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"exchange"
                                                 objcPrefix:@"serviceexchange"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - serviceexchangeMessageUserNotice

@implementation serviceexchangeMessageUserNotice

@dynamic version;
@dynamic hasTemplateNotice, templateNotice;
@dynamic hasChatNotice, chatNotice;
@dynamic hasPushNotice, pushNotice;

typedef struct serviceexchangeMessageUserNotice__storage_ {
  uint32_t _has_storage_[1];
  serviceexchangeMessageUserNotice_TemplateNotice *templateNotice;
  serviceexchangeMessageUserNotice_ChatNotice *chatNotice;
  serviceexchangeMessageUserNotice_PushNotice *pushNotice;
  uint64_t version;
} serviceexchangeMessageUserNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeMessageUserNotice_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(serviceexchangeMessageUserNotice__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "templateNotice",
        .dataTypeSpecific.clazz = GPBObjCClass(serviceexchangeMessageUserNotice_TemplateNotice),
        .number = serviceexchangeMessageUserNotice_FieldNumber_TemplateNotice,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(serviceexchangeMessageUserNotice__storage_, templateNotice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chatNotice",
        .dataTypeSpecific.clazz = GPBObjCClass(serviceexchangeMessageUserNotice_ChatNotice),
        .number = serviceexchangeMessageUserNotice_FieldNumber_ChatNotice,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(serviceexchangeMessageUserNotice__storage_, chatNotice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pushNotice",
        .dataTypeSpecific.clazz = GPBObjCClass(serviceexchangeMessageUserNotice_PushNotice),
        .number = serviceexchangeMessageUserNotice_FieldNumber_PushNotice,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(serviceexchangeMessageUserNotice__storage_, pushNotice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[serviceexchangeMessageUserNotice class]
                                     rootClass:[serviceexchangeExchangePrimaryPushNoticeRoot class]
                                          file:serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(serviceexchangeMessageUserNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - serviceexchangeMessageUserNotice_TemplateNotice

@implementation serviceexchangeMessageUserNotice_TemplateNotice

@dynamic hasMessageCount, messageCount;
@dynamic hasVersionId, versionId;

typedef struct serviceexchangeMessageUserNotice_TemplateNotice__storage_ {
  uint32_t _has_storage_[1];
  serviceexchangeMessageCount *messageCount;
  serviceexchangeVersionId *versionId;
} serviceexchangeMessageUserNotice_TemplateNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageCount",
        .dataTypeSpecific.clazz = GPBObjCClass(serviceexchangeMessageCount),
        .number = serviceexchangeMessageUserNotice_TemplateNotice_FieldNumber_MessageCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(serviceexchangeMessageUserNotice_TemplateNotice__storage_, messageCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "versionId",
        .dataTypeSpecific.clazz = GPBObjCClass(serviceexchangeVersionId),
        .number = serviceexchangeMessageUserNotice_TemplateNotice_FieldNumber_VersionId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(serviceexchangeMessageUserNotice_TemplateNotice__storage_, versionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[serviceexchangeMessageUserNotice_TemplateNotice class]
                                     rootClass:[serviceexchangeExchangePrimaryPushNoticeRoot class]
                                          file:serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(serviceexchangeMessageUserNotice_TemplateNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(serviceexchangeMessageUserNotice)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - serviceexchangeMessageUserNotice_ChatNotice

@implementation serviceexchangeMessageUserNotice_ChatNotice

@dynamic hasMessageCount, messageCount;
@dynamic hasGroupId, groupId;
@dynamic hasVersionId, versionId;
@dynamic hasTalkWithUid, talkWithUid;

typedef struct serviceexchangeMessageUserNotice_ChatNotice__storage_ {
  uint32_t _has_storage_[1];
  serviceexchangeMessageCount *messageCount;
  utilidentitysdkIdEncode *groupId;
  serviceexchangeVersionId *versionId;
  utilidentitysdkIdEncode *talkWithUid;
} serviceexchangeMessageUserNotice_ChatNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageCount",
        .dataTypeSpecific.clazz = GPBObjCClass(serviceexchangeMessageCount),
        .number = serviceexchangeMessageUserNotice_ChatNotice_FieldNumber_MessageCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(serviceexchangeMessageUserNotice_ChatNotice__storage_, messageCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = GPBObjCClass(utilidentitysdkIdEncode),
        .number = serviceexchangeMessageUserNotice_ChatNotice_FieldNumber_GroupId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(serviceexchangeMessageUserNotice_ChatNotice__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "versionId",
        .dataTypeSpecific.clazz = GPBObjCClass(serviceexchangeVersionId),
        .number = serviceexchangeMessageUserNotice_ChatNotice_FieldNumber_VersionId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(serviceexchangeMessageUserNotice_ChatNotice__storage_, versionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "talkWithUid",
        .dataTypeSpecific.clazz = GPBObjCClass(utilidentitysdkIdEncode),
        .number = serviceexchangeMessageUserNotice_ChatNotice_FieldNumber_TalkWithUid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(serviceexchangeMessageUserNotice_ChatNotice__storage_, talkWithUid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[serviceexchangeMessageUserNotice_ChatNotice class]
                                     rootClass:[serviceexchangeExchangePrimaryPushNoticeRoot class]
                                          file:serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(serviceexchangeMessageUserNotice_ChatNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(serviceexchangeMessageUserNotice)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - serviceexchangeMessageUserNotice_PushNotice

@implementation serviceexchangeMessageUserNotice_PushNotice

@dynamic type;
@dynamic hasMessageCount, messageCount;
@dynamic content;

typedef struct serviceexchangeMessageUserNotice_PushNotice__storage_ {
  uint32_t _has_storage_[1];
  NSString *type;
  serviceexchangeMessageCount *messageCount;
  NSString *content;
} serviceexchangeMessageUserNotice_PushNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeMessageUserNotice_PushNotice_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(serviceexchangeMessageUserNotice_PushNotice__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "messageCount",
        .dataTypeSpecific.clazz = GPBObjCClass(serviceexchangeMessageCount),
        .number = serviceexchangeMessageUserNotice_PushNotice_FieldNumber_MessageCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(serviceexchangeMessageUserNotice_PushNotice__storage_, messageCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeMessageUserNotice_PushNotice_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(serviceexchangeMessageUserNotice_PushNotice__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[serviceexchangeMessageUserNotice_PushNotice class]
                                     rootClass:[serviceexchangeExchangePrimaryPushNoticeRoot class]
                                          file:serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(serviceexchangeMessageUserNotice_PushNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(serviceexchangeMessageUserNotice)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - serviceexchangeUserStatusNotice

@implementation serviceexchangeUserStatusNotice

@dynamic version;
@dynamic hasPushNotice, pushNotice;

typedef struct serviceexchangeUserStatusNotice__storage_ {
  uint32_t _has_storage_[1];
  serviceexchangeUserStatusNotice_PushNotice *pushNotice;
  uint64_t version;
} serviceexchangeUserStatusNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeUserStatusNotice_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(serviceexchangeUserStatusNotice__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pushNotice",
        .dataTypeSpecific.clazz = GPBObjCClass(serviceexchangeUserStatusNotice_PushNotice),
        .number = serviceexchangeUserStatusNotice_FieldNumber_PushNotice,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(serviceexchangeUserStatusNotice__storage_, pushNotice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[serviceexchangeUserStatusNotice class]
                                     rootClass:[serviceexchangeExchangePrimaryPushNoticeRoot class]
                                          file:serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(serviceexchangeUserStatusNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - serviceexchangeUserStatusNotice_PushNotice

@implementation serviceexchangeUserStatusNotice_PushNotice

@dynamic type;
@dynamic content;

typedef struct serviceexchangeUserStatusNotice_PushNotice__storage_ {
  uint32_t _has_storage_[1];
  NSString *type;
  NSString *content;
} serviceexchangeUserStatusNotice_PushNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeUserStatusNotice_PushNotice_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(serviceexchangeUserStatusNotice_PushNotice__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeUserStatusNotice_PushNotice_FieldNumber_Content,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(serviceexchangeUserStatusNotice_PushNotice__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[serviceexchangeUserStatusNotice_PushNotice class]
                                     rootClass:[serviceexchangeExchangePrimaryPushNoticeRoot class]
                                          file:serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(serviceexchangeUserStatusNotice_PushNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(serviceexchangeUserStatusNotice)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - serviceexchangeLiveGiftNotice

@implementation serviceexchangeLiveGiftNotice

@dynamic version;
@dynamic errorMessage;
@dynamic hasPushNotice, pushNotice;

typedef struct serviceexchangeLiveGiftNotice__storage_ {
  uint32_t _has_storage_[1];
  NSString *errorMessage;
  serviceexchangeLiveGiftNotice_PushNotice *pushNotice;
  uint64_t version;
} serviceexchangeLiveGiftNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeLiveGiftNotice_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(serviceexchangeLiveGiftNotice__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "errorMessage",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeLiveGiftNotice_FieldNumber_ErrorMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(serviceexchangeLiveGiftNotice__storage_, errorMessage),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushNotice",
        .dataTypeSpecific.clazz = GPBObjCClass(serviceexchangeLiveGiftNotice_PushNotice),
        .number = serviceexchangeLiveGiftNotice_FieldNumber_PushNotice,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(serviceexchangeLiveGiftNotice__storage_, pushNotice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[serviceexchangeLiveGiftNotice class]
                                     rootClass:[serviceexchangeExchangePrimaryPushNoticeRoot class]
                                          file:serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(serviceexchangeLiveGiftNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - serviceexchangeLiveGiftNotice_PushNotice

@implementation serviceexchangeLiveGiftNotice_PushNotice

@dynamic hasGiftId, giftId;
@dynamic giftCount;
@dynamic hasChatUser, chatUser;
@dynamic audienceLevel;

typedef struct serviceexchangeLiveGiftNotice_PushNotice__storage_ {
  uint32_t _has_storage_[1];
  uint32_t giftCount;
  uint32_t audienceLevel;
  utilidentitysdkIdEncode *giftId;
  serviceexchangeChatUser *chatUser;
} serviceexchangeLiveGiftNotice_PushNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "giftId",
        .dataTypeSpecific.clazz = GPBObjCClass(utilidentitysdkIdEncode),
        .number = serviceexchangeLiveGiftNotice_PushNotice_FieldNumber_GiftId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(serviceexchangeLiveGiftNotice_PushNotice__storage_, giftId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "giftCount",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeLiveGiftNotice_PushNotice_FieldNumber_GiftCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(serviceexchangeLiveGiftNotice_PushNotice__storage_, giftCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "chatUser",
        .dataTypeSpecific.clazz = GPBObjCClass(serviceexchangeChatUser),
        .number = serviceexchangeLiveGiftNotice_PushNotice_FieldNumber_ChatUser,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(serviceexchangeLiveGiftNotice_PushNotice__storage_, chatUser),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audienceLevel",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeLiveGiftNotice_PushNotice_FieldNumber_AudienceLevel,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(serviceexchangeLiveGiftNotice_PushNotice__storage_, audienceLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[serviceexchangeLiveGiftNotice_PushNotice class]
                                     rootClass:[serviceexchangeExchangePrimaryPushNoticeRoot class]
                                          file:serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(serviceexchangeLiveGiftNotice_PushNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(serviceexchangeLiveGiftNotice)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - serviceexchangeEnterLiveNotice

@implementation serviceexchangeEnterLiveNotice

@dynamic version;
@dynamic hasPushNotice, pushNotice;

typedef struct serviceexchangeEnterLiveNotice__storage_ {
  uint32_t _has_storage_[1];
  serviceexchangeEnterLiveNotice_PushNotice *pushNotice;
  uint64_t version;
} serviceexchangeEnterLiveNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeEnterLiveNotice_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(serviceexchangeEnterLiveNotice__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pushNotice",
        .dataTypeSpecific.clazz = GPBObjCClass(serviceexchangeEnterLiveNotice_PushNotice),
        .number = serviceexchangeEnterLiveNotice_FieldNumber_PushNotice,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(serviceexchangeEnterLiveNotice__storage_, pushNotice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[serviceexchangeEnterLiveNotice class]
                                     rootClass:[serviceexchangeExchangePrimaryPushNoticeRoot class]
                                          file:serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(serviceexchangeEnterLiveNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - serviceexchangeEnterLiveNotice_PushNotice

@implementation serviceexchangeEnterLiveNotice_PushNotice

@dynamic hasChatUser, chatUser;
@dynamic audienceLevel;
@dynamic currentLiveRewardAmount;
@dynamic enterLiveRoomTime;
@dynamic firstEnter;

typedef struct serviceexchangeEnterLiveNotice_PushNotice__storage_ {
  uint32_t _has_storage_[1];
  uint32_t audienceLevel;
  uint32_t currentLiveRewardAmount;
  serviceexchangeChatUser *chatUser;
  uint64_t enterLiveRoomTime;
} serviceexchangeEnterLiveNotice_PushNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatUser",
        .dataTypeSpecific.clazz = GPBObjCClass(serviceexchangeChatUser),
        .number = serviceexchangeEnterLiveNotice_PushNotice_FieldNumber_ChatUser,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(serviceexchangeEnterLiveNotice_PushNotice__storage_, chatUser),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audienceLevel",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeEnterLiveNotice_PushNotice_FieldNumber_AudienceLevel,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(serviceexchangeEnterLiveNotice_PushNotice__storage_, audienceLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "currentLiveRewardAmount",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeEnterLiveNotice_PushNotice_FieldNumber_CurrentLiveRewardAmount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(serviceexchangeEnterLiveNotice_PushNotice__storage_, currentLiveRewardAmount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "enterLiveRoomTime",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeEnterLiveNotice_PushNotice_FieldNumber_EnterLiveRoomTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(serviceexchangeEnterLiveNotice_PushNotice__storage_, enterLiveRoomTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "firstEnter",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeEnterLiveNotice_PushNotice_FieldNumber_FirstEnter,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[serviceexchangeEnterLiveNotice_PushNotice class]
                                     rootClass:[serviceexchangeExchangePrimaryPushNoticeRoot class]
                                          file:serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(serviceexchangeEnterLiveNotice_PushNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(serviceexchangeEnterLiveNotice)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - serviceexchangeExitLiveNotice

@implementation serviceexchangeExitLiveNotice

@dynamic version;
@dynamic hasPushNotice, pushNotice;

typedef struct serviceexchangeExitLiveNotice__storage_ {
  uint32_t _has_storage_[1];
  serviceexchangeExitLiveNotice_PushNotice *pushNotice;
  uint64_t version;
} serviceexchangeExitLiveNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeExitLiveNotice_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(serviceexchangeExitLiveNotice__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pushNotice",
        .dataTypeSpecific.clazz = GPBObjCClass(serviceexchangeExitLiveNotice_PushNotice),
        .number = serviceexchangeExitLiveNotice_FieldNumber_PushNotice,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(serviceexchangeExitLiveNotice__storage_, pushNotice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[serviceexchangeExitLiveNotice class]
                                     rootClass:[serviceexchangeExchangePrimaryPushNoticeRoot class]
                                          file:serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(serviceexchangeExitLiveNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - serviceexchangeExitLiveNotice_PushNotice

@implementation serviceexchangeExitLiveNotice_PushNotice

@dynamic hasAudienceUid, audienceUid;
@dynamic hasListResponse, listResponse;

typedef struct serviceexchangeExitLiveNotice_PushNotice__storage_ {
  uint32_t _has_storage_[1];
  utilidentitysdkIdEncode *audienceUid;
  serviceexchangeLiveUserListResponse *listResponse;
} serviceexchangeExitLiveNotice_PushNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "audienceUid",
        .dataTypeSpecific.clazz = GPBObjCClass(utilidentitysdkIdEncode),
        .number = serviceexchangeExitLiveNotice_PushNotice_FieldNumber_AudienceUid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(serviceexchangeExitLiveNotice_PushNotice__storage_, audienceUid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "listResponse",
        .dataTypeSpecific.clazz = GPBObjCClass(serviceexchangeLiveUserListResponse),
        .number = serviceexchangeExitLiveNotice_PushNotice_FieldNumber_ListResponse,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(serviceexchangeExitLiveNotice_PushNotice__storage_, listResponse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[serviceexchangeExitLiveNotice_PushNotice class]
                                     rootClass:[serviceexchangeExchangePrimaryPushNoticeRoot class]
                                          file:serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(serviceexchangeExitLiveNotice_PushNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(serviceexchangeExitLiveNotice)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - serviceexchangeCloseLiveNotice

@implementation serviceexchangeCloseLiveNotice

@dynamic version;
@dynamic hasPushNotice, pushNotice;

typedef struct serviceexchangeCloseLiveNotice__storage_ {
  uint32_t _has_storage_[1];
  serviceexchangeCloseLiveNotice_PushNotice *pushNotice;
  uint64_t version;
} serviceexchangeCloseLiveNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeCloseLiveNotice_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(serviceexchangeCloseLiveNotice__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pushNotice",
        .dataTypeSpecific.clazz = GPBObjCClass(serviceexchangeCloseLiveNotice_PushNotice),
        .number = serviceexchangeCloseLiveNotice_FieldNumber_PushNotice,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(serviceexchangeCloseLiveNotice__storage_, pushNotice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[serviceexchangeCloseLiveNotice class]
                                     rootClass:[serviceexchangeExchangePrimaryPushNoticeRoot class]
                                          file:serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(serviceexchangeCloseLiveNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - serviceexchangeCloseLiveNotice_PushNotice

@implementation serviceexchangeCloseLiveNotice_PushNotice

@dynamic hasLiveId, liveId;

typedef struct serviceexchangeCloseLiveNotice_PushNotice__storage_ {
  uint32_t _has_storage_[1];
  utilidentitysdkIdEncode *liveId;
} serviceexchangeCloseLiveNotice_PushNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "liveId",
        .dataTypeSpecific.clazz = GPBObjCClass(utilidentitysdkIdEncode),
        .number = serviceexchangeCloseLiveNotice_PushNotice_FieldNumber_LiveId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(serviceexchangeCloseLiveNotice_PushNotice__storage_, liveId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[serviceexchangeCloseLiveNotice_PushNotice class]
                                     rootClass:[serviceexchangeExchangePrimaryPushNoticeRoot class]
                                          file:serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(serviceexchangeCloseLiveNotice_PushNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(serviceexchangeCloseLiveNotice)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - serviceexchangeChatLiveNotice

@implementation serviceexchangeChatLiveNotice

@dynamic version;
@dynamic hasPushNotice, pushNotice;

typedef struct serviceexchangeChatLiveNotice__storage_ {
  uint32_t _has_storage_[1];
  serviceexchangeChatLiveNotice_PushNotice *pushNotice;
  uint64_t version;
} serviceexchangeChatLiveNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeChatLiveNotice_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(serviceexchangeChatLiveNotice__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pushNotice",
        .dataTypeSpecific.clazz = GPBObjCClass(serviceexchangeChatLiveNotice_PushNotice),
        .number = serviceexchangeChatLiveNotice_FieldNumber_PushNotice,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(serviceexchangeChatLiveNotice__storage_, pushNotice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[serviceexchangeChatLiveNotice class]
                                     rootClass:[serviceexchangeExchangePrimaryPushNoticeRoot class]
                                          file:serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(serviceexchangeChatLiveNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - serviceexchangeChatLiveNotice_PushNotice

@implementation serviceexchangeChatLiveNotice_PushNotice

@dynamic hasChatUser, chatUser;
@dynamic content;
@dynamic audienceLevel;

typedef struct serviceexchangeChatLiveNotice_PushNotice__storage_ {
  uint32_t _has_storage_[1];
  uint32_t audienceLevel;
  serviceexchangeChatUser *chatUser;
  NSString *content;
} serviceexchangeChatLiveNotice_PushNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatUser",
        .dataTypeSpecific.clazz = GPBObjCClass(serviceexchangeChatUser),
        .number = serviceexchangeChatLiveNotice_PushNotice_FieldNumber_ChatUser,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(serviceexchangeChatLiveNotice_PushNotice__storage_, chatUser),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeChatLiveNotice_PushNotice_FieldNumber_Content,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(serviceexchangeChatLiveNotice_PushNotice__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "audienceLevel",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeChatLiveNotice_PushNotice_FieldNumber_AudienceLevel,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(serviceexchangeChatLiveNotice_PushNotice__storage_, audienceLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[serviceexchangeChatLiveNotice_PushNotice class]
                                     rootClass:[serviceexchangeExchangePrimaryPushNoticeRoot class]
                                          file:serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(serviceexchangeChatLiveNotice_PushNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(serviceexchangeChatLiveNotice)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - serviceexchangeStarLiveNotice

@implementation serviceexchangeStarLiveNotice

@dynamic version;

typedef struct serviceexchangeStarLiveNotice__storage_ {
  uint32_t _has_storage_[1];
  uint64_t version;
} serviceexchangeStarLiveNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeStarLiveNotice_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(serviceexchangeStarLiveNotice__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[serviceexchangeStarLiveNotice class]
                                     rootClass:[serviceexchangeExchangePrimaryPushNoticeRoot class]
                                          file:serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(serviceexchangeStarLiveNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - serviceexchangeAnchorApplyNotice

@implementation serviceexchangeAnchorApplyNotice

@dynamic version;
@dynamic hasPushNotice, pushNotice;

typedef struct serviceexchangeAnchorApplyNotice__storage_ {
  uint32_t _has_storage_[1];
  serviceexchangeAnchorApplyNotice_PushNotice *pushNotice;
  uint64_t version;
} serviceexchangeAnchorApplyNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeAnchorApplyNotice_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(serviceexchangeAnchorApplyNotice__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pushNotice",
        .dataTypeSpecific.clazz = GPBObjCClass(serviceexchangeAnchorApplyNotice_PushNotice),
        .number = serviceexchangeAnchorApplyNotice_FieldNumber_PushNotice,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(serviceexchangeAnchorApplyNotice__storage_, pushNotice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[serviceexchangeAnchorApplyNotice class]
                                     rootClass:[serviceexchangeExchangePrimaryPushNoticeRoot class]
                                          file:serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(serviceexchangeAnchorApplyNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - serviceexchangeAnchorApplyNotice_PushNotice

@implementation serviceexchangeAnchorApplyNotice_PushNotice

@dynamic applyLiveStatus;
@dynamic auditFailReason;

typedef struct serviceexchangeAnchorApplyNotice_PushNotice__storage_ {
  uint32_t _has_storage_[1];
  serviceexchangeApplyLiveStatus applyLiveStatus;
  NSString *auditFailReason;
} serviceexchangeAnchorApplyNotice_PushNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "applyLiveStatus",
        .dataTypeSpecific.enumDescFunc = serviceexchangeApplyLiveStatus_EnumDescriptor,
        .number = serviceexchangeAnchorApplyNotice_PushNotice_FieldNumber_ApplyLiveStatus,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(serviceexchangeAnchorApplyNotice_PushNotice__storage_, applyLiveStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "auditFailReason",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeAnchorApplyNotice_PushNotice_FieldNumber_AuditFailReason,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(serviceexchangeAnchorApplyNotice_PushNotice__storage_, auditFailReason),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[serviceexchangeAnchorApplyNotice_PushNotice class]
                                     rootClass:[serviceexchangeExchangePrimaryPushNoticeRoot class]
                                          file:serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(serviceexchangeAnchorApplyNotice_PushNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(serviceexchangeAnchorApplyNotice)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t serviceexchangeAnchorApplyNotice_PushNotice_ApplyLiveStatus_RawValue(serviceexchangeAnchorApplyNotice_PushNotice *message) {
  GPBDescriptor *descriptor = [serviceexchangeAnchorApplyNotice_PushNotice descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:serviceexchangeAnchorApplyNotice_PushNotice_FieldNumber_ApplyLiveStatus];
  return GPBGetMessageRawEnumField(message, field);
}

void SetserviceexchangeAnchorApplyNotice_PushNotice_ApplyLiveStatus_RawValue(serviceexchangeAnchorApplyNotice_PushNotice *message, int32_t value) {
  GPBDescriptor *descriptor = [serviceexchangeAnchorApplyNotice_PushNotice descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:serviceexchangeAnchorApplyNotice_PushNotice_FieldNumber_ApplyLiveStatus];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - serviceexchangeAnchorLeaveLiveNotice

@implementation serviceexchangeAnchorLeaveLiveNotice

@dynamic version;
@dynamic hasPushNotice, pushNotice;

typedef struct serviceexchangeAnchorLeaveLiveNotice__storage_ {
  uint32_t _has_storage_[1];
  serviceexchangeAnchorLeaveLiveNotice_PushNotice *pushNotice;
  uint64_t version;
} serviceexchangeAnchorLeaveLiveNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeAnchorLeaveLiveNotice_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(serviceexchangeAnchorLeaveLiveNotice__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pushNotice",
        .dataTypeSpecific.clazz = GPBObjCClass(serviceexchangeAnchorLeaveLiveNotice_PushNotice),
        .number = serviceexchangeAnchorLeaveLiveNotice_FieldNumber_PushNotice,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(serviceexchangeAnchorLeaveLiveNotice__storage_, pushNotice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[serviceexchangeAnchorLeaveLiveNotice class]
                                     rootClass:[serviceexchangeExchangePrimaryPushNoticeRoot class]
                                          file:serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(serviceexchangeAnchorLeaveLiveNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - serviceexchangeAnchorLeaveLiveNotice_PushNotice

@implementation serviceexchangeAnchorLeaveLiveNotice_PushNotice

@dynamic hasLiveId, liveId;

typedef struct serviceexchangeAnchorLeaveLiveNotice_PushNotice__storage_ {
  uint32_t _has_storage_[1];
  utilidentitysdkIdEncode *liveId;
} serviceexchangeAnchorLeaveLiveNotice_PushNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "liveId",
        .dataTypeSpecific.clazz = GPBObjCClass(utilidentitysdkIdEncode),
        .number = serviceexchangeAnchorLeaveLiveNotice_PushNotice_FieldNumber_LiveId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(serviceexchangeAnchorLeaveLiveNotice_PushNotice__storage_, liveId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[serviceexchangeAnchorLeaveLiveNotice_PushNotice class]
                                     rootClass:[serviceexchangeExchangePrimaryPushNoticeRoot class]
                                          file:serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(serviceexchangeAnchorLeaveLiveNotice_PushNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(serviceexchangeAnchorLeaveLiveNotice)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - serviceexchangeAnchorBackLiveNotice

@implementation serviceexchangeAnchorBackLiveNotice

@dynamic version;
@dynamic hasPushNotice, pushNotice;

typedef struct serviceexchangeAnchorBackLiveNotice__storage_ {
  uint32_t _has_storage_[1];
  serviceexchangeAnchorBackLiveNotice_PushNotice *pushNotice;
  uint64_t version;
} serviceexchangeAnchorBackLiveNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = serviceexchangeAnchorBackLiveNotice_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(serviceexchangeAnchorBackLiveNotice__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pushNotice",
        .dataTypeSpecific.clazz = GPBObjCClass(serviceexchangeAnchorBackLiveNotice_PushNotice),
        .number = serviceexchangeAnchorBackLiveNotice_FieldNumber_PushNotice,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(serviceexchangeAnchorBackLiveNotice__storage_, pushNotice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[serviceexchangeAnchorBackLiveNotice class]
                                     rootClass:[serviceexchangeExchangePrimaryPushNoticeRoot class]
                                          file:serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(serviceexchangeAnchorBackLiveNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - serviceexchangeAnchorBackLiveNotice_PushNotice

@implementation serviceexchangeAnchorBackLiveNotice_PushNotice

@dynamic hasLiveId, liveId;

typedef struct serviceexchangeAnchorBackLiveNotice_PushNotice__storage_ {
  uint32_t _has_storage_[1];
  utilidentitysdkIdEncode *liveId;
} serviceexchangeAnchorBackLiveNotice_PushNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "liveId",
        .dataTypeSpecific.clazz = GPBObjCClass(utilidentitysdkIdEncode),
        .number = serviceexchangeAnchorBackLiveNotice_PushNotice_FieldNumber_LiveId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(serviceexchangeAnchorBackLiveNotice_PushNotice__storage_, liveId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[serviceexchangeAnchorBackLiveNotice_PushNotice class]
                                     rootClass:[serviceexchangeExchangePrimaryPushNoticeRoot class]
                                          file:serviceexchangeExchangePrimaryPushNoticeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(serviceexchangeAnchorBackLiveNotice_PushNotice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(serviceexchangeAnchorBackLiveNotice)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
