// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: appv-primary-api-content.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "AppvPrimaryApiContent.pbobjc.h"
#import "AppvBasic.pbobjc.h"
#import "AppvOss.pbobjc.h"
#import "AppvPrimaryBasic.pbobjc.h"
#import "AppvPrimaryContent.pbobjc.h"
#import "AppvPrimaryTag.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(appvapiContentAudit);
GPBObjCClassDeclaration(appvapiContentSvideo);
GPBObjCClassDeclaration(appvapiContentTag);
GPBObjCClassDeclaration(appvapiCreateVideoTag);
GPBObjCClassDeclaration(appvapiFavoritesContentSvideo);
GPBObjCClassDeclaration(appvapiIdEncode);
GPBObjCClassDeclaration(appvapiLikesContentSvideo);
GPBObjCClassDeclaration(appvapiMIMEInfo);
GPBObjCClassDeclaration(appvapiMyContentSvideo);
GPBObjCClassDeclaration(appvapiPublishingVideo);
GPBObjCClassDeclaration(appvapiTopic);
GPBObjCClassDeclaration(appvapiTopicFeed);
GPBObjCClassDeclaration(appvapiVideoTag);

#pragma mark - appvapiAppvPrimaryApiContentRoot

@implementation appvapiAppvPrimaryApiContentRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - appvapiAppvPrimaryApiContentRoot_FileDescriptor

static GPBFileDescriptor *appvapiAppvPrimaryApiContentRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"appvapi"
                                                 objcPrefix:@"appvapi"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum appvapiContentStatus

GPBEnumDescriptor *appvapiContentStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Created\000Auditing\000AuditDeny\000AuditPass\000";
    static const int32_t values[] = {
        appvapiContentStatus_Created,
        appvapiContentStatus_Auditing,
        appvapiContentStatus_AuditDeny,
        appvapiContentStatus_AuditPass,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(appvapiContentStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:appvapiContentStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      
    }
  }
  return descriptor;
}

BOOL appvapiContentStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case appvapiContentStatus_Created:
    case appvapiContentStatus_Auditing:
    case appvapiContentStatus_AuditDeny:
    case appvapiContentStatus_AuditPass:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum appvapiDenyReason

GPBEnumDescriptor *appvapiDenyReason_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000";
    static const int32_t values[] = {
        appvapiDenyReason_Ok,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(appvapiDenyReason)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:appvapiDenyReason_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      
    }
  }
  return descriptor;
}

BOOL appvapiDenyReason_IsValidValue(int32_t value__) {
  switch (value__) {
    case appvapiDenyReason_Ok:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - appvapiBatchCreateVideoTag

@implementation appvapiBatchCreateVideoTag

@dynamic createVideoTagsArray, createVideoTagsArray_Count;

typedef struct appvapiBatchCreateVideoTag__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *createVideoTagsArray;
} appvapiBatchCreateVideoTag__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "createVideoTagsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiCreateVideoTag),
        .number = appvapiBatchCreateVideoTag_FieldNumber_CreateVideoTagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(appvapiBatchCreateVideoTag__storage_, createVideoTagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiBatchCreateVideoTag class]
                                     rootClass:[appvapiAppvPrimaryApiContentRoot class]
                                          file:appvapiAppvPrimaryApiContentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiBatchCreateVideoTag__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiCreateVideoTag

@implementation appvapiCreateVideoTag

@dynamic tagName;

typedef struct appvapiCreateVideoTag__storage_ {
  uint32_t _has_storage_[1];
  NSString *tagName;
} appvapiCreateVideoTag__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tagName",
        .dataTypeSpecific.clazz = Nil,
        .number = appvapiCreateVideoTag_FieldNumber_TagName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiCreateVideoTag__storage_, tagName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiCreateVideoTag class]
                                     rootClass:[appvapiAppvPrimaryApiContentRoot class]
                                          file:appvapiAppvPrimaryApiContentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiCreateVideoTag__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiCreateVideoTagResponse

@implementation appvapiCreateVideoTagResponse

@dynamic videoTagsArray, videoTagsArray_Count;

typedef struct appvapiCreateVideoTagResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *videoTagsArray;
} appvapiCreateVideoTagResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "videoTagsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiVideoTag),
        .number = appvapiCreateVideoTagResponse_FieldNumber_VideoTagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(appvapiCreateVideoTagResponse__storage_, videoTagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiCreateVideoTagResponse class]
                                     rootClass:[appvapiAppvPrimaryApiContentRoot class]
                                          file:appvapiAppvPrimaryApiContentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiCreateVideoTagResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiVideoTag

@implementation appvapiVideoTag

@dynamic hasId_p, id_p;
@dynamic tagName;

typedef struct appvapiVideoTag__storage_ {
  uint32_t _has_storage_[1];
  appvapiIdEncode *id_p;
  NSString *tagName;
} appvapiVideoTag__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiIdEncode),
        .number = appvapiVideoTag_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiVideoTag__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tagName",
        .dataTypeSpecific.clazz = Nil,
        .number = appvapiVideoTag_FieldNumber_TagName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(appvapiVideoTag__storage_, tagName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiVideoTag class]
                                     rootClass:[appvapiAppvPrimaryApiContentRoot class]
                                          file:appvapiAppvPrimaryApiContentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiVideoTag__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiLikesShortVideoListResponse

@implementation appvapiLikesShortVideoListResponse

@dynamic videosArray, videosArray_Count;

typedef struct appvapiLikesShortVideoListResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *videosArray;
} appvapiLikesShortVideoListResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "videosArray",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiLikesContentSvideo),
        .number = appvapiLikesShortVideoListResponse_FieldNumber_VideosArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(appvapiLikesShortVideoListResponse__storage_, videosArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiLikesShortVideoListResponse class]
                                     rootClass:[appvapiAppvPrimaryApiContentRoot class]
                                          file:appvapiAppvPrimaryApiContentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiLikesShortVideoListResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiFavoritesShortVideoListResponse

@implementation appvapiFavoritesShortVideoListResponse

@dynamic videosArray, videosArray_Count;

typedef struct appvapiFavoritesShortVideoListResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *videosArray;
} appvapiFavoritesShortVideoListResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "videosArray",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiFavoritesContentSvideo),
        .number = appvapiFavoritesShortVideoListResponse_FieldNumber_VideosArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(appvapiFavoritesShortVideoListResponse__storage_, videosArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiFavoritesShortVideoListResponse class]
                                     rootClass:[appvapiAppvPrimaryApiContentRoot class]
                                          file:appvapiAppvPrimaryApiContentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiFavoritesShortVideoListResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiLikesContentSvideo

@implementation appvapiLikesContentSvideo

@dynamic hasVideo, video;
@dynamic hasLikeId, likeId;

typedef struct appvapiLikesContentSvideo__storage_ {
  uint32_t _has_storage_[1];
  appvapiContentSvideo *video;
  appvapiIdEncode *likeId;
} appvapiLikesContentSvideo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "video",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiContentSvideo),
        .number = appvapiLikesContentSvideo_FieldNumber_Video,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiLikesContentSvideo__storage_, video),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "likeId",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiIdEncode),
        .number = appvapiLikesContentSvideo_FieldNumber_LikeId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(appvapiLikesContentSvideo__storage_, likeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiLikesContentSvideo class]
                                     rootClass:[appvapiAppvPrimaryApiContentRoot class]
                                          file:appvapiAppvPrimaryApiContentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiLikesContentSvideo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiFavoritesContentSvideo

@implementation appvapiFavoritesContentSvideo

@dynamic hasVideo, video;
@dynamic hasFavoritesId, favoritesId;

typedef struct appvapiFavoritesContentSvideo__storage_ {
  uint32_t _has_storage_[1];
  appvapiContentSvideo *video;
  appvapiIdEncode *favoritesId;
} appvapiFavoritesContentSvideo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "video",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiContentSvideo),
        .number = appvapiFavoritesContentSvideo_FieldNumber_Video,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiFavoritesContentSvideo__storage_, video),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "favoritesId",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiIdEncode),
        .number = appvapiFavoritesContentSvideo_FieldNumber_FavoritesId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(appvapiFavoritesContentSvideo__storage_, favoritesId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiFavoritesContentSvideo class]
                                     rootClass:[appvapiAppvPrimaryApiContentRoot class]
                                          file:appvapiAppvPrimaryApiContentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiFavoritesContentSvideo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiPublishingRequest

@implementation appvapiPublishingRequest

@dynamic title;
@dynamic tagsArray, tagsArray_Count;
@dynamic hasCoverFile, coverFile;
@dynamic hasVideoFile, videoFile;
@dynamic hasFirstFrameFile, firstFrameFile;
@dynamic tagIdsArray, tagIdsArray_Count;

typedef struct appvapiPublishingRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSMutableArray *tagsArray;
  appvapiMIMEInfo *coverFile;
  appvapiMIMEInfo *videoFile;
  appvapiMIMEInfo *firstFrameFile;
  NSMutableArray *tagIdsArray;
} appvapiPublishingRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = appvapiPublishingRequest_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiPublishingRequest__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tagsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiContentTag),
        .number = appvapiPublishingRequest_FieldNumber_TagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(appvapiPublishingRequest__storage_, tagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "coverFile",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiMIMEInfo),
        .number = appvapiPublishingRequest_FieldNumber_CoverFile,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(appvapiPublishingRequest__storage_, coverFile),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "videoFile",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiMIMEInfo),
        .number = appvapiPublishingRequest_FieldNumber_VideoFile,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(appvapiPublishingRequest__storage_, videoFile),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "firstFrameFile",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiMIMEInfo),
        .number = appvapiPublishingRequest_FieldNumber_FirstFrameFile,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(appvapiPublishingRequest__storage_, firstFrameFile),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tagIdsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiIdEncode),
        .number = appvapiPublishingRequest_FieldNumber_TagIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(appvapiPublishingRequest__storage_, tagIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiPublishingRequest class]
                                     rootClass:[appvapiAppvPrimaryApiContentRoot class]
                                          file:appvapiAppvPrimaryApiContentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiPublishingRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiPublishingStreamVideoRequest

@implementation appvapiPublishingStreamVideoRequest

@dynamic title;
@dynamic tagsArray, tagsArray_Count;
@dynamic hasCoverFile, coverFile;
@dynamic hasFirstFrameFile, firstFrameFile;
@dynamic hasVideoIndex, videoIndex;
@dynamic videoFragmentsArray, videoFragmentsArray_Count;
@dynamic tagIdsArray, tagIdsArray_Count;

typedef struct appvapiPublishingStreamVideoRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSMutableArray *tagsArray;
  appvapiMIMEInfo *coverFile;
  appvapiMIMEInfo *firstFrameFile;
  appvapiMIMEInfo *videoIndex;
  NSMutableArray *videoFragmentsArray;
  NSMutableArray *tagIdsArray;
} appvapiPublishingStreamVideoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = appvapiPublishingStreamVideoRequest_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiPublishingStreamVideoRequest__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tagsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiContentTag),
        .number = appvapiPublishingStreamVideoRequest_FieldNumber_TagsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(appvapiPublishingStreamVideoRequest__storage_, tagsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "coverFile",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiMIMEInfo),
        .number = appvapiPublishingStreamVideoRequest_FieldNumber_CoverFile,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(appvapiPublishingStreamVideoRequest__storage_, coverFile),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "firstFrameFile",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiMIMEInfo),
        .number = appvapiPublishingStreamVideoRequest_FieldNumber_FirstFrameFile,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(appvapiPublishingStreamVideoRequest__storage_, firstFrameFile),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "videoIndex",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiMIMEInfo),
        .number = appvapiPublishingStreamVideoRequest_FieldNumber_VideoIndex,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(appvapiPublishingStreamVideoRequest__storage_, videoIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "videoFragmentsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiMIMEInfo),
        .number = appvapiPublishingStreamVideoRequest_FieldNumber_VideoFragmentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(appvapiPublishingStreamVideoRequest__storage_, videoFragmentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tagIdsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiIdEncode),
        .number = appvapiPublishingStreamVideoRequest_FieldNumber_TagIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(appvapiPublishingStreamVideoRequest__storage_, tagIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiPublishingStreamVideoRequest class]
                                     rootClass:[appvapiAppvPrimaryApiContentRoot class]
                                          file:appvapiAppvPrimaryApiContentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiPublishingStreamVideoRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiListTopicFeedsRequest

@implementation appvapiListTopicFeedsRequest

@dynamic offset;

typedef struct appvapiListTopicFeedsRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t offset;
} appvapiListTopicFeedsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = appvapiListTopicFeedsRequest_FieldNumber_Offset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiListTopicFeedsRequest__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiListTopicFeedsRequest class]
                                     rootClass:[appvapiAppvPrimaryApiContentRoot class]
                                          file:appvapiAppvPrimaryApiContentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiListTopicFeedsRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiListTopicNextFeedsRequest

@implementation appvapiListTopicNextFeedsRequest

@dynamic hasTopicId, topicId;
@dynamic offset;

typedef struct appvapiListTopicNextFeedsRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t offset;
  appvapiIdEncode *topicId;
} appvapiListTopicNextFeedsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "topicId",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiIdEncode),
        .number = appvapiListTopicNextFeedsRequest_FieldNumber_TopicId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiListTopicNextFeedsRequest__storage_, topicId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = appvapiListTopicNextFeedsRequest_FieldNumber_Offset,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(appvapiListTopicNextFeedsRequest__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiListTopicNextFeedsRequest class]
                                     rootClass:[appvapiAppvPrimaryApiContentRoot class]
                                          file:appvapiAppvPrimaryApiContentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiListTopicNextFeedsRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiListTopicFeedsResponse

@implementation appvapiListTopicFeedsResponse

@dynamic topicFeedsArray, topicFeedsArray_Count;

typedef struct appvapiListTopicFeedsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *topicFeedsArray;
} appvapiListTopicFeedsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "topicFeedsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiTopicFeed),
        .number = appvapiListTopicFeedsResponse_FieldNumber_TopicFeedsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(appvapiListTopicFeedsResponse__storage_, topicFeedsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiListTopicFeedsResponse class]
                                     rootClass:[appvapiAppvPrimaryApiContentRoot class]
                                          file:appvapiAppvPrimaryApiContentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiListTopicFeedsResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiTopicFeed

@implementation appvapiTopicFeed

@dynamic hasTopic, topic;
@dynamic videosArray, videosArray_Count;

typedef struct appvapiTopicFeed__storage_ {
  uint32_t _has_storage_[1];
  appvapiTopic *topic;
  NSMutableArray *videosArray;
} appvapiTopicFeed__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "topic",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiTopic),
        .number = appvapiTopicFeed_FieldNumber_Topic,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiTopicFeed__storage_, topic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "videosArray",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiContentSvideo),
        .number = appvapiTopicFeed_FieldNumber_VideosArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(appvapiTopicFeed__storage_, videosArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiTopicFeed class]
                                     rootClass:[appvapiAppvPrimaryApiContentRoot class]
                                          file:appvapiAppvPrimaryApiContentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiTopicFeed__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiMyContentSvideoAppendList

@implementation appvapiMyContentSvideoAppendList

@dynamic videosArray, videosArray_Count;
@dynamic hasPublishingVideo, publishingVideo;

typedef struct appvapiMyContentSvideoAppendList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *videosArray;
  appvapiPublishingVideo *publishingVideo;
} appvapiMyContentSvideoAppendList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "videosArray",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiMyContentSvideo),
        .number = appvapiMyContentSvideoAppendList_FieldNumber_VideosArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(appvapiMyContentSvideoAppendList__storage_, videosArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "publishingVideo",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiPublishingVideo),
        .number = appvapiMyContentSvideoAppendList_FieldNumber_PublishingVideo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiMyContentSvideoAppendList__storage_, publishingVideo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiMyContentSvideoAppendList class]
                                     rootClass:[appvapiAppvPrimaryApiContentRoot class]
                                          file:appvapiAppvPrimaryApiContentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiMyContentSvideoAppendList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiMyContentSvideo

@implementation appvapiMyContentSvideo

@dynamic hasBasicInfo, basicInfo;
@dynamic hasAudit, audit;

typedef struct appvapiMyContentSvideo__storage_ {
  uint32_t _has_storage_[1];
  appvapiContentSvideo *basicInfo;
  appvapiContentAudit *audit;
} appvapiMyContentSvideo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "basicInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiContentSvideo),
        .number = appvapiMyContentSvideo_FieldNumber_BasicInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiMyContentSvideo__storage_, basicInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audit",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiContentAudit),
        .number = appvapiMyContentSvideo_FieldNumber_Audit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(appvapiMyContentSvideo__storage_, audit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiMyContentSvideo class]
                                     rootClass:[appvapiAppvPrimaryApiContentRoot class]
                                          file:appvapiAppvPrimaryApiContentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiMyContentSvideo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiPublishingVideo

@implementation appvapiPublishingVideo

@dynamic publishingCount;

typedef struct appvapiPublishingVideo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t publishingCount;
} appvapiPublishingVideo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "publishingCount",
        .dataTypeSpecific.clazz = Nil,
        .number = appvapiPublishingVideo_FieldNumber_PublishingCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiPublishingVideo__storage_, publishingCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiPublishingVideo class]
                                     rootClass:[appvapiAppvPrimaryApiContentRoot class]
                                          file:appvapiAppvPrimaryApiContentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiPublishingVideo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiContentAudit

@implementation appvapiContentAudit

@dynamic status;
@dynamic denyReason;
@dynamic reason;

typedef struct appvapiContentAudit__storage_ {
  uint32_t _has_storage_[1];
  appvapiContentStatus status;
  appvapiDenyReason denyReason;
  NSString *reason;
} appvapiContentAudit__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = appvapiContentStatus_EnumDescriptor,
        .number = appvapiContentAudit_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiContentAudit__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "denyReason",
        .dataTypeSpecific.enumDescFunc = appvapiDenyReason_EnumDescriptor,
        .number = appvapiContentAudit_FieldNumber_DenyReason,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(appvapiContentAudit__storage_, denyReason),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "reason",
        .dataTypeSpecific.clazz = Nil,
        .number = appvapiContentAudit_FieldNumber_Reason,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(appvapiContentAudit__storage_, reason),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiContentAudit class]
                                     rootClass:[appvapiAppvPrimaryApiContentRoot class]
                                          file:appvapiAppvPrimaryApiContentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiContentAudit__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t appvapiContentAudit_Status_RawValue(appvapiContentAudit *message) {
  GPBDescriptor *descriptor = [appvapiContentAudit descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:appvapiContentAudit_FieldNumber_Status];
  return GPBGetMessageRawEnumField(message, field);
}

void SetappvapiContentAudit_Status_RawValue(appvapiContentAudit *message, int32_t value) {
  GPBDescriptor *descriptor = [appvapiContentAudit descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:appvapiContentAudit_FieldNumber_Status];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t appvapiContentAudit_DenyReason_RawValue(appvapiContentAudit *message) {
  GPBDescriptor *descriptor = [appvapiContentAudit descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:appvapiContentAudit_FieldNumber_DenyReason];
  return GPBGetMessageRawEnumField(message, field);
}

void SetappvapiContentAudit_DenyReason_RawValue(appvapiContentAudit *message, int32_t value) {
  GPBDescriptor *descriptor = [appvapiContentAudit descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:appvapiContentAudit_FieldNumber_DenyReason];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - appvapiListTagVideosRequest

@implementation appvapiListTagVideosRequest

@dynamic hasTagId, tagId;
@dynamic tagName;
@dynamic offset;

typedef struct appvapiListTagVideosRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t offset;
  appvapiIdEncode *tagId;
  NSString *tagName;
} appvapiListTagVideosRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tagId",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiIdEncode),
        .number = appvapiListTagVideosRequest_FieldNumber_TagId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiListTagVideosRequest__storage_, tagId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tagName",
        .dataTypeSpecific.clazz = Nil,
        .number = appvapiListTagVideosRequest_FieldNumber_TagName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(appvapiListTagVideosRequest__storage_, tagName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = appvapiListTagVideosRequest_FieldNumber_Offset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(appvapiListTagVideosRequest__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiListTagVideosRequest class]
                                     rootClass:[appvapiAppvPrimaryApiContentRoot class]
                                          file:appvapiAppvPrimaryApiContentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiListTagVideosRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiTopic

@implementation appvapiTopic

@dynamic hasTopicId, topicId;
@dynamic topicName;
@dynamic hasTopicListId, topicListId;

typedef struct appvapiTopic__storage_ {
  uint32_t _has_storage_[1];
  appvapiIdEncode *topicId;
  NSString *topicName;
  appvapiIdEncode *topicListId;
} appvapiTopic__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "topicId",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiIdEncode),
        .number = appvapiTopic_FieldNumber_TopicId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(appvapiTopic__storage_, topicId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "topicName",
        .dataTypeSpecific.clazz = Nil,
        .number = appvapiTopic_FieldNumber_TopicName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(appvapiTopic__storage_, topicName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "topicListId",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiIdEncode),
        .number = appvapiTopic_FieldNumber_TopicListId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(appvapiTopic__storage_, topicListId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiTopic class]
                                     rootClass:[appvapiAppvPrimaryApiContentRoot class]
                                          file:appvapiAppvPrimaryApiContentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiTopic__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - appvapiBatchGetSVideosRequest

@implementation appvapiBatchGetSVideosRequest

@dynamic videoIdsArray, videoIdsArray_Count;

typedef struct appvapiBatchGetSVideosRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *videoIdsArray;
} appvapiBatchGetSVideosRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "videoIdsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(appvapiIdEncode),
        .number = appvapiBatchGetSVideosRequest_FieldNumber_VideoIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(appvapiBatchGetSVideosRequest__storage_, videoIdsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[appvapiBatchGetSVideosRequest class]
                                     rootClass:[appvapiAppvPrimaryApiContentRoot class]
                                          file:appvapiAppvPrimaryApiContentRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(appvapiBatchGetSVideosRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
